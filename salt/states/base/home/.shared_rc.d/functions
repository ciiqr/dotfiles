#!/usr/bin/env bash

inplace-replace() {
	# TODO: This can probably be improved, or at least better documented...
	sed -i "s/$(echo $1 | sed -e 's/\([[\/.*]\|\]\)/\\&/g')/$(echo $2 | sed -e 's/[\/&]/\\&/g')/g" $3
}

watch-process-time() {
	watch -n 1 "ps -eo etime,command | grep $1 | grep -v grep"
}

rec-readlink() {
	find . -type l -print0 | while IFS= read -r -d $'\0' file; do
		echo -n "$file "
		readlink "$@" "$file"
	done
}

generate-pem() {
	declare name="$1"
	if [[ -z "$name" ]]; then
		echo "usage: ${FUNCNAME[0]:-$funcstack[1]} key-name"
		return 1
	fi

	# RSA Private Key
	openssl genrsa -out "$name".pem 4096

	# OpenSSL public key
	# openssl rsa -in "$name".pem -pubout > "$name".pub

	# OpenSSH public key
	chmod 0600 "$name".pem
	\ssh-keygen -y -f "$name".pem > "$name".pub
}

generate-rsa() {
    declare name="$1"
    if [[ -z "$name" ]]; then
        echo "usage: ${FUNCNAME[0]:-$funcstack[1]} key-name"
        return 1
    fi

    \ssh-keygen -t rsa -b 4096 -o -N "" -f "$name" -C "$name"
}

largest()
{
	if [[ "$#" -eq 0 ]]; then
		sudo du -sh ./{,.}* 2>&1 | egrep -v '(^[0-9\.]+K|^0\s|No such file or directory)' | sort -h
	else
		sudo du -sh "$@" 2>&1 | egrep -v '(^[0-9\.]+K|^0\s|No such file or directory)' | sort -h
	fi
}

smallest()
{
	if [[ "$#" -eq 0 ]]; then
		sudo du -sh .* * 2>&1 | egrep '^([0-9\.]+K|0\s)' | sort -hr
	else
		sudo du -sh "$@" 2>&1 | egrep '^([0-9\.]+K|0\s)' | sort -hr
	fi
}

notify-complete()
{
	# TODO: add osx support
	local cmd="$@"
	$@ && notify-send "$cmd" "Complete" || notify-send "$cmd" "Failed"
}

until_failure()
{
    declare retCode=0
    declare temp="`mktemp`"
    declare count=0

    while [[ "$retCode" == "0" ]]; do
        "$@" >"$temp" 2>&1
        retCode="$?"

        clear
        cat "$temp"
        if [[ $temp != *$'\n' ]]; then
            echo
        fi

        if [[ "$retCode" == "0" ]]; then
            ((count++))
            tput setab 2
            echo -n "$count runs without failure"
            tput sgr0
            echo ": $@"
        fi
    done

    tput setab 1
    echo -n "$count runs without failure"
    tput sgr0
    echo ": $@"
}

while_failing()
{
    declare retCode=1
    declare temp="`mktemp`"
    declare count=0

    while [[ "$retCode" != "0" ]]; do
        "$@" >"$temp" 2>&1
        retCode="$?"

        clear
        cat "$temp"

        if [[ "$retCode" != "0" ]]; then
            ((count++))
            tput setab 1
            echo -n "$count runs without success"
            tput sgr0
            echo ": $@"
        fi
    done

    tput setab 2
    echo -n "$count runs without success"
    tput sgr0
    echo ": $@"
}

healthcheck()
{
    # TODO: it would be nice to have a summary if the time every once in a while (maybe just based on the width of the column)
    declare retCode=1
    declare count=0

    while true; do
        sleep_then "$@" >/dev/null 2>&1
        retCode="$?"

        ((count++))
        if [[ "$retCode" == "0" ]]; then
            tput setab 2
            echo -n "."
            tput sgr0
        else
            tput setab 1
            echo -n "x"
            tput sgr0
        fi

        # TODO: 60 is kinda arbitrary, it would be better to be (terminal width - date width - padding)
        # TODO: for now we're assuming term is about 80 wide, date is about 20 wide
        if (( $count % 60 == 0 )); then
            echo -n ' '
            date '+%Y-%m-%d %H:%M:%S'
        fi
    done
}

print_x()
{
    # ie. print_x 10 2
    # 2222222222

    local x="$1"
    shift
    while ((x--)); do
        echo -n "$@"
    done

    echo
}

print_seq()
{
    # ie. print_seq 2 5
    # 2
    # 3
    # 4
    # 5

    # ie. print_seq 5 2 3
    # 5
    # 2

    local x="$1"
    local y="$2"
    local skip="$3"

    if [[ -z "$skip" ]]; then
        skip=1
    fi

    if ((x > y)); then
        # counting down
        while ((x >= y)); do
            echo "$x"
            ((x -= skip))
        done
    else
        # counting up
        while ((x <= y)); do
            echo "$x"
            ((x += skip))
        done
    fi
}

pomo()
{
    declare minutes="$1"
    declare i="0"

    if [[ -z "$minutes" ]]; then
        minutes="15"
    fi

    if ! type "send_notification" >/dev/null 2>&1; then
        echo "$0: send_notification not configured for this platform"
        exit 1
    fi

    # TODO: consider supporting alternating sleep times (ie. 15m/5m/15m/5m/etc)
    while true; do
        sleep $((minutes * 60))
        ((i++))
        send_notification "$i" "POMO"
    done
}

mime-type()
{
    if command-exists xdg-mime; then
        if [[ $# == 1 ]]; then
            xdg-mime query filetype "$1"
        else
            for file in "$@"; do
                echo "$file: $(xdg-mime query filetype "$file")"
            done
        fi
    else
        file --mime-type "$@"
    fi
}

bak() {
    # TODO: check params`
    cp -a "$1" "$1.bak"
}

unbak() {
    # TODO: check params
    cp -a "$1.bak" "$1"
}

top-n-by-count()
{
    declare CHAR="/"
    declare base="${1%/}/"
    declare n="${2:-0}"

    # count is relative to path, and defaults to show children of path
    n=$(awk -F"$CHAR" '{print NF+'"$n"'}' <<< "${base}")

    # split on /, get n parts, and count
    cut -d"$CHAR" -f 1-"$n" | sort | uniq -c | sort -h
}

locate-top-n-by-count()
{
    declare base="${1%/}/"
    declare n="$2"
    # TODO: check params
    locate "$base" | top-n-by-count "$base" "$n"
}
find-top-n-by-count()
{
    declare base="${1%/}/"
    declare n="$2"
    # TODO: check params
    sudo find "$base" | top-n-by-count "$base" "$n"
}

macro()
{
    (source macro "$@")
}
