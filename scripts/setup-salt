#!/usr/bin/env bash

set -e

forrealz(){ realpath "$@" 2>/dev/null || readlink -f "$@"; }
srcDir="$(dirname "$(forrealz "${BASH_SOURCE[0]}")")"

. "$srcDir/include/common.sh"

parse_cli_args "$@" || usage "$0"

ensureRoot

# create salt directory
mkdir -p "$saltDir"


# setup configs

# files
tee "$saltDir/files.conf" > /dev/null <<EOF
ext_pillar:
  - stack: $configDir/salt/pillar/stack.sls

file_roots:
  base:
    ${privateConfigDir:+- $privateConfigDir/salt/states}
    - $configDir/salt/states

pillar_roots:
  base:
    ${privateConfigDir:+- $privateConfigDir/salt/pillar}
    - $configDir/salt/pillar
EOF

# minion
ln -sf "$configDir/salt/etc/minion.yaml" "$saltDir/minion"
if [[ -n "$privateConfigDir" ]]; then
    ln -sf "$privateConfigDir/salt/etc/machines.yaml" "$saltDir/machines.yaml"
fi

# grains

# sync modules
salt-call saltutil.refresh_modules --out quiet

# determine platform
platform=$(salt-call platform.get_name --out newline_values_only)
if [[ -z "$platform" ]]; then
    echo 'unknown platform' >&2
    exit 1
fi

# determine primary user, if detected user is root, try using the existing primaryUser
if [[ -z "$primaryUser" ]]; then
    primaryUser="$(salt-call grains.get primaryUser --out newline_values_only)"
    if [[ -z "$primaryUser" ]]; then
        primaryUser="$(logname)"
    fi
fi

# if roles are not specified, try getting the existing roles
if [[ -z "$roles" ]]; then
    roles="$(salt-call grains.get roles --out newline_values_only)"
fi

# set config/private-config dirs
salt-call grains.set configDir "$configDir" --out quiet
salt-call grains.set privateConfigDir "$privateConfigDir" --out quiet

# set user
salt-call grains.set primaryUser "$primaryUser" --out quiet

# set platform
salt-call grains.set platform "$platform" --out quiet

# set roles
salt-call grains.delkey roles --out quiet
for role in $roles; do
     salt-call grains.append roles "$role" --out quiet
done


# apply bootstrap state (for installing package managers and such)
salt-call state.apply bootstrap
