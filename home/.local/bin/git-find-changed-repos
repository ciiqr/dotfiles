#!/usr/bin/env bash

set -e

. ~/.scripts/lib/output.sh

usage() {
    echo 'usage: git-find-changed-repos [--porcelain|--diff] [--fetch] [<directory>...]'
    echo '   ie. git-find-changed-repos ~/Projects'
}

error() {
    echo "git-find-changed-repos:" "$@" 1>&2
}

parse_args() {
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --porcelain)
                porcelain='true'
                ;;
            --diff)
                diff='true'
                ;;
            --fetch)
                fetch='true'
                ;;
            -h | --help)
                usage
                exit 0
                ;;
            -*)
                error "Unrecognized option $1"
                return 1
                ;;
            *)
                # positional args are assumed to be directories to search through
                directories+=("$1")
                ;;
        esac
        shift
    done
}

validate_args() {
    if [[ "$porcelain" == 'true' && "$diff" == 'true' ]]; then
        error 'Invalid use of mutually exclusive args --porcelain and --diff'
        echo
        usage
        return 1
    fi
}

is_repo_changed() {
    declare repo_dir="$1"

    # if any files changed/untracked
    if [[ "$(git -C "$repo_dir" status --porcelain 2>/dev/null)" != "" ]]; then
        return 0
    fi

    # if no upstream branch
    if ! git -C "$repo_dir" rev-parse --abbrev-ref --symbolic-full-name '@{u}' >/dev/null 2>&1; then
        return 0
    fi

    # ahead/behind remote
    if [[ -n "$(git -C "$repo_dir" rev-list --left-right '@{u}'...HEAD)" ]]; then
        return 0
    fi

    # get main branch
    declare head_branch_ref
    head_branch_ref="$(git -C "$repo_dir" rev-parse --abbrev-ref --symbolic-full-name origin/HEAD)"
    declare head_branch="${head_branch_ref#origin/}"
    if [[ -z "$head_branch" ]]; then
        head_branch='main'
    fi

    # not on main branch
    if [[ "$(git -C "$repo_dir" branch --show-current)" != "$head_branch" ]]; then
        return 0
    fi

    return 1
}

declare porcelain='false'
declare diff='false'
declare fetch='false'
declare -a directories=()

parse_args "$@"
validate_args

if [[ -t 1 ]]; then
    declare should_colour='true'
else
    declare should_colour='false'
fi

# colour output
declare -a git_args=()
if [[ "$should_colour" == 'true' ]]; then
    git_args+=('-c' 'color.status=always')
fi

# TODO: consider optimizing to not search in subdirectories of git repos (probs optionally still do tho)
# https://stackoverflow.com/questions/11981716/how-to-quickly-find-all-git-repos-under-a-directory

# find all git repos
while IFS= read -r -d $'\0' dot_git; do
    declare repo_dir
    repo_dir="$(dirname "$dot_git")"

    if [[ "$fetch" == 'true' ]]; then
        # TODO: -a ?
        git -C "$repo_dir" fetch
    fi

    if is_repo_changed "$repo_dir"; then
        # print repo directory header
        output::header "${repo_dir/#${HOME}/'~'}"

        if [[ "$diff" == 'true' ]]; then
            # subcommand args
            declare -a git_diff_args=()
            if [[ "$should_colour" == 'true' ]]; then
                git_diff_args+=('--color=always')
            fi

            # git diff
            git -C "$repo_dir" "${git_args[@]}" diff "${git_diff_args[@]}" | output::indent
        else
            # subcommand args
            declare -a git_status_args=()
            if [[ "$porcelain" == 'true' ]]; then
                git_status_args+=('--porcelain')
            fi

            # git status
            git -C "$repo_dir" "${git_args[@]}" status "${git_status_args[@]}" | output::indent
        fi
    fi
done < <(
    # TODO: sync with git-repos-exec
    find "${directories[@]:-.}" \
        -name .git -type d -prune -print0 \
        -o -name .cargo -type d -prune \
        -o -name .rustup -type d -prune \
        -o -name .fingerprint -type d -prune \
        -o -name .next -type d -prune \
        -o -name node_modules -type d -prune \
        -o -name build -type d -prune \
        -o -name dist -type d -prune \
        -o -name target -type d -prune \
        -o -name .vagrant -type d -prune \
        -o -name .direnv -type d -prune \
        -o -name .stversions -type d -prune
)
