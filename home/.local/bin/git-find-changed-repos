#!/usr/bin/env bash

set -e

. ~/.scripts/lib/output.sh

usage() {
    echo 'usage: git-find-changed-repos [--porcelain|--diff] [<directory>...]'
    echo '   ie. git-find-changed-repos ~/Projects'
}

error() {
    echo "git-find-changed-repos:" "$@" 1>&2
}

parse_args() {
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --porcelain)
                porcelain='true'
                ;;
            --diff)
                diff='true'
                ;;
            -h | --help)
                usage
                exit 0
                ;;
            -*)
                error "Unrecognized option $1"
                return 1
                ;;
            *)
                # positional args are assumed to be directories to search through
                directories+=("$1")
                ;;
        esac
        shift
    done
}

validate_args() {
    if [[ "$porcelain" == 'true' && "$diff" == 'true' ]]; then
        error 'Invalid use of mutually exclusive args --porcelain and --diff'
        echo
        usage
        return 1
    fi
}

declare porcelain='false'
declare diff='false'
declare -a directories=()

parse_args "$@"
validate_args

if [[ -t 1 ]]; then
    declare should_colour='true'
else
    declare should_colour='false'
fi

# colour output
declare -a git_args=()
if [[ "$should_colour" == 'true' ]]; then
    git_args+=('-c' 'color.status=always')
fi

# TODO: consider optimizing to not search in subdirectories of git repos (probs optionally still do tho)
# https://stackoverflow.com/questions/11981716/how-to-quickly-find-all-git-repos-under-a-directory

# find all git repos
while IFS= read -r -d $'\0' dot_git; do
    declare repo_dir
    repo_dir="$(dirname "$dot_git")"

    # if any files changed or untracked
    if [[ "$(git -C "$repo_dir" status --porcelain 2>/dev/null)" != "" ]]; then
        # print repo directory header
        output::header "${repo_dir/#${HOME}/'~'}"

        if [[ "$diff" == 'true' ]]; then
            # subcommand args
            declare -a git_diff_args=()
            if [[ "$should_colour" == 'true' ]]; then
                git_diff_args+=('--color=always')
            fi

            # git diff
            git -C "$repo_dir" "${git_args[@]}" diff "${git_diff_args[@]}" | output::indent
        else
            # subcommand args
            declare -a git_status_args=()
            if [[ "$porcelain" == 'true' ]]; then
                git_status_args+=('--porcelain')
            fi

            # git status
            git -C "$repo_dir" "${git_args[@]}" status "${git_status_args[@]}" | output::indent
        fi
    fi
done < <(
    # TODO: sync with git-repos-exec
    find "${directories[@]:-.}" \
        -name .git -type d -prune -print0 \
        -o -name .cargo -type d -prune \
        -o -name .rustup -type d -prune \
        -o -name .fingerprint -type d -prune \
        -o -name .next -type d -prune \
        -o -name node_modules -type d -prune \
        -o -name build -type d -prune \
        -o -name dist -type d -prune \
        -o -name target -type d -prune \
        -o -name .vagrant -type d -prune \
        -o -name .direnv -type d -prune \
        -o -name .stversions -type d -prune \
        2>/dev/null
)
